;;; -*- lexical-binding: t; no-byte-compile: t; -*-

(defvar elpaca-installer-version 0.11)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil :depth 1 :inherit ignore
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (<= emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                  ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                  ,@(when-let* ((depth (plist-get order :depth)))
                                                      (list (format "--depth=%d" depth) "--no-single-branch"))
                                                  ,(plist-get order :repo) ,repo))))
                  ((zerop (call-process "git" nil buffer t "checkout"
                                        (or (plist-get order :ref) "--"))))
                  (emacs (concat invocation-directory invocation-name))
                  ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                        "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                  ((require 'elpaca))
                  ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (let ((load-source-file-function nil)) (load "./elpaca-autoloads"))))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))

(elpaca elpaca-use-package
  (elpaca-use-package-mode))

;; FIX; apparently elpaca will prefer built-in and not pull in what magit needs
;; This can probably go away in the future versions of Emacs
;; https://github.com/progfolio/elpaca/issues/272#issuecomment-2298727726
(setq elpaca-ignored-dependencies
      (delq 'transient elpaca-ignored-dependencies))

(setq use-package-always-defer t)

(use-package emacs
  ;; credit: autogenerated setup by ChatGPT "5 Thinking" (ãƒ„)_/Â¯
  :ensure nil
  :preface
  ;; ----- defs

  ;; 1) Projects dir
  (defvar grok-projects "~/repos"
    "Absolute path to your projects directory (used by Magit/Projectile/etc).")

  ;; 2) Evil toggle
  (defvar grok-evil-mode nil
    "Non-nil enables Evil-mode setup during bootstrap.")

  ;; 3) Theme gating: t -> configure theme; nil -> angry-fruit vanilla (skip rest).
  (defvar grok-theme t
    "When non-nil, configure a theme; when nil, skip theme/appearance prompts.")

  ;; 4) Theme style: \"fancy\" or \"minimal\"
  (defvar grok-theme-style "fancy"
    "Theme style preference: \"fancy\" or \"minimal\".")

  ;; Fancy-only variables (package theme)
  (defvar grok-custom-theme-pkg 'doom-themes
    "Fancy style: theme package to install/use (e.g., 'doom-themes).")
  (defvar grok-custom-theme 'doom-one
    "Fancy style: theme symbol from the package (e.g., 'doom-one).")

  ;; Minimal-only variable (built-in theme)
  (defvar grok-custom-built-in-theme 'modus-operandi
    "Minimal style: built-in theme symbol (e.g., 'modus-operandi).")

  (defvar grok-use-modeline "doom"
    "Modeline style: may be one of \"doom\" or \"spaceline\", or \"none\"")

  ;; 5) Alpha background (string: \"0\"â€“\"99\"; \"\" or \"100\" disables).
  (defvar grok-alpha-background "100"
    "Alpha transparency percent as string \"0\"â€“\"99\"; \"\" or \"100\" disables.")

  ;; 6) Font family
  (defvar grok-font "Source Code Pro"
    "Preferred monospace font family installed on the system.")

  ;; 7) Font size (string)
  (defvar grok-font-size "11"
    "Preferred font size in points as a string (e.g., \"11\").")

  ;; 8/9) Line numbers (+ optional relative)
  (defvar grok-line-numbers nil
    "Non-nil shows line numbers globally where appropriate.")
  (defvar grok-relative-line-numbers nil
    "Non-nil enables relative line numbers when line numbers are on.")

  ;; ----- interactive initial setup (writes ~/.emacs.d/grok-opts.el)
  (defvar grok-opts-file (expand-file-name "grok-opts.el" user-emacs-directory)
    "Path to the persisted Grok options file.")

  (defun grok--ensure-opts (&optional force)
    "Ensure `grok-opts-file` exists; with FORCE recreate via minibuffer prompts; then load it.
Order:
1) grok-projects
2) grok-evil-mode
3) grok-theme (angry-fruit if nil -> skip remaining)
4) grok-theme-style (\"fancy\"|\"minimal\")
   - minimal -> set grok-custom-theme-pkg=nil; ask built-in theme -> grok-custom-built-in-theme
   - fancy   -> ask package -> grok-custom-theme-pkg; ask theme -> grok-custom-theme
5) grok-alpha-background
6) grok-font
7) grok-font-size
8) grok-line-numbers (+ 9) grok-relative-line-numbers followup"
    (interactive "P")
    (let ((use-dialog-box nil)
          (use-file-dialog nil)
          (opts-file grok-opts-file))
      (when (or force (not (file-exists-p opts-file)))
        (with-temp-file opts-file
          (insert ";;; -*- lexical-binding: t; no-byte-compile: t; -*-\n\n")

          ;; 1) Projects directory
          (let* ((fallback (and (boundp 'grok-projects) grok-projects))
                 (dir (read-directory-name "ðŸ“‚ Projects dir: "
                                           (and fallback (expand-file-name fallback))
                                           nil t)))
            (prin1 `(setq grok-projects ,dir) (current-buffer)) (insert "\n"))

          ;; 2) Evil
          (let ((ans (y-or-n-p "ðŸ˜ˆ Enable Evil mode? [y] ðŸ˜‡ or Holy mode [n] ")))
            (prin1 `(setq grok-evil-mode ,ans) (current-buffer)) (insert "\n"))

          ;; 3) Theme gating
          (let ((use-theme (y-or-n-p "ðŸ§™ Continue to theme customization wizard? ðŸŠâœ¨ ")))
            (prin1 `(setq grok-theme ,use-theme) (current-buffer)) (insert "\n")

            (when use-theme
              ;; 4) Theme style
              (let* ((style (completing-read "ðŸŽ¨ Theme style (âœ¨ fancy | ðŸ“¦ minimal): "
                                             '("fancy" "minimal") nil t
                                             (or (and (boundp 'grok-theme-style) grok-theme-style)
                                                 "fancy"))))
                (prin1 `(setq grok-theme-style ,style) (current-buffer)) (insert "\n")

                (if (string= style "minimal")
                    (progn
                      (prin1 `(setq grok-custom-theme-pkg nil) (current-buffer)) (insert "\n")
                      (let* ((def (if (and (boundp 'grok-custom-built-in-theme)
                                           (symbolp grok-custom-built-in-theme))
                                      (symbol-name grok-custom-built-in-theme)
                                    "modus-operandi"))
                             (th (intern (completing-read "ðŸŽ¨ Built-in theme: "
                                                          '("modus-operandi" "modus-vivendi")
                                                          nil nil def))))
                        (prin1 `(setq grok-custom-built-in-theme ',th) (current-buffer)) (insert "\n")))
                  ;; fancy
                  (let* ((defpkg (if (and (boundp 'grok-custom-theme-pkg)
                                          (symbolp grok-custom-theme-pkg))
                                     (symbol-name grok-custom-theme-pkg)
                                   "doom-themes"))
                         (pkg (intern (read-from-minibuffer
                                       "ðŸ“¦ Theme package to install: " defpkg)))
                         (deftheme (if (and (boundp 'grok-custom-theme)
                                            (symbolp grok-custom-theme))
                                       (symbol-name grok-custom-theme)
                                     "doom-one"))
                         (th (intern (read-from-minibuffer
                                      "ðŸŽ¨ Theme name from that package: " deftheme))))
                    (prin1 `(setq grok-custom-theme-pkg ',pkg) (current-buffer)) (insert "\n")
                    (prin1 `(setq grok-custom-theme ',th) (current-buffer)) (insert "\n")
                    ;; NEW: modeline style (only for fancy)
                    (let* ((defml (or (and (boundp 'grok-use-modeline) grok-use-modeline) "doom"))
                           (ml (completing-read "âŒ˜ Modeline (doom|spaceline|none): "
                                                '("doom" "spaceline" "none") nil t defml)))
                      (prin1 `(setq grok-use-modeline ,ml) (current-buffer)) (insert "\n")))))

              ;; 5) Alpha background
              (let* ((def (or (and (boundp 'grok-alpha-background) grok-alpha-background) ""))
                     (val (read-string "ðŸªŸ Transparency (0â€“99, [enter]/100 = off): " def)))
                (prin1 `(setq grok-alpha-background ,val) (current-buffer)) (insert "\n"))

              ;; 6) Font family
              (let* ((def (or (and (boundp 'grok-font) grok-font) "Source Code Pro"))
                     (val (read-string "ðŸ”¤ Font (must be on system): " def)))
                (prin1 `(setq grok-font ,val) (current-buffer)) (insert "\n"))

              ;; 7) Font size
              (let* ((def (or (and (boundp 'grok-font-size) grok-font-size) "11"))
                     (val (read-string "ðŸ“ Font Size: " def)))
                (prin1 `(setq grok-font-size ,val) (current-buffer)) (insert "\n"))

              ;; 8) Line numbers (+ 9) relative follow-up
              (let ((ln (y-or-n-p "ðŸ”¢ Show line numbers? ")))
                (prin1 `(setq grok-line-numbers ,ln) (current-buffer)) (insert "\n")
                (when ln
                  (let ((rel (y-or-n-p "ðŸ”¢âž¡ï¸ Use relative line numbers? ")))
                    (prin1 `(setq grok-relative-line-numbers ,rel) (current-buffer)) (insert "\n")))))))
        (with-temp-buffer
          (insert "\n\n;; additional settings\n")
          (insert ";; (setq grok-core-disabled '())\n")
          (insert ";; (setq grok-window-pop-enabled t)\n")
          (insert ";; (setq grok-window-pop-splash t)\n")
          (insert ";; (setq grok-window-pop-splash-timer 3)\n")
          (append-to-file (point-min) (point-max) grok-opts-file)))

      (load opts-file t t)))

  :init
  ;; ----- first things
  (setq load-prefer-newer t
        gc-cons-threshold 100000000
        read-process-output-max (* 1024 1024)
        comp-deferred-compilation t
        package-native-compile t)

  ;; don't pop-up compilation warnings during native compiles / confuse the user
  (setq native-comp-async-report-warnings-errors nil
        comp-async-report-warnings-errors nil)
  (add-to-list 'warning-suppress-types '(native-compiler))
  (add-to-list 'warning-suppress-types '(native-compiler))
  (add-to-list 'display-buffer-alist '("\\*Warnings\\*" (display-buffer-no-window) (allow-no-window . t)))

  :config
  (grok--ensure-opts))

(use-package emacs
  ;; credit: autogenerated setup by ChatGPT "5 Thinking" (ãƒ„)_/Â¯
  ;; Can be used to automate some particular use-package for the user, currently only used by grok-theme-fancy to pull in the theme requested during setup
  :ensure nil
  :preface
  (defmacro grok--use-pkg-programmatic (&rest specs)
    (declare (indent defun))
    `(progn
       ,@(mapcar
          (lambda (spec)
            (let* ((pkg (if (consp spec) (car spec) spec))
                   (props (if (consp spec) (cdr spec) '()))
                   (pkg-sym
                    (cond
                     ((and (symbolp pkg) (boundp pkg) (symbolp (symbol-value pkg)))
                      (symbol-value pkg))
                     ((symbolp pkg) pkg)
                     (t (error "Invalid package spec: %S" spec))))
                   (ensure (if (plist-member props :ensure)
                               (plist-get props :ensure)
                             t))
                   (ini (plist-get props :init))
                   (cfg (plist-get props :config))
                   (ini-forms (cond
                               ((null ini) nil)
                               ((and (listp ini) (listp (car ini))) ini)
                               (t (list ini))))
                   (cfg-forms (cond
                               ((null cfg) nil)
                               ((and (listp cfg) (listp (car cfg))) cfg)
                               (t (list cfg)))))
              `(use-package ,pkg-sym
                 :ensure ,ensure
                 ,@(when ini-forms `(:init ,@ini-forms))
                 ,@(when cfg-forms `(:config ,@cfg-forms)))))
          specs))))

(use-package emacs
  ;; credit: autogenerated setup by ChatGPT "5 Thinking" (ãƒ„)_/Â¯
  :ensure nil
  :preface
  (defvar grok-env nil
    "Alist of extra environment variables to set (SYMBOL|STRING . VALUE).")

  (defvar grok-path-insert nil
    "List of directories to insert at the front of `exec-path`.")

  (defvar grok-path-append nil
    "List of directories to append to the end of `exec-path`.")

  (defun grok-apply-env-and-path ()
    "Apply ENV/PATH customization."

    ;; ENV
    (dolist (pair (and (boundp 'grok-env) grok-env))
      (let* ((var (if (symbolp (car pair)) (symbol-name (car pair)) (car pair)))
             (raw (cdr pair))
             (val (substitute-env-vars (if (stringp raw) raw (format "%s" raw)))))
        (setenv var val)))

    ;; PATH
    (dolist (item (and (boundp 'grok-path-insert) grok-path-insert))
      (add-to-list 'exec-path (expand-file-name item)))
    (dolist (item (and (boundp 'grok-path-append) grok-path-append))
      (add-to-list 'exec-path (expand-file-name item) t))

    (setenv "PATH" (string-trim-right (string-join exec-path ":") ":$"))))

(use-package emacs
  ;; credit: autogenerated setup by ChatGPT "5 Thinking" (ãƒ„)_/Â¯
  :ensure nil
  :preface
  (defvar grok-eglot-autostart-langs nil
    "Alist of (HOOK . SPEC) for automatic Eglot startup.
Each SPEC may be a string (command), a list of strings (command and args),
or (:override . CMD) to override `eglot-server-programs`.")

  (defun grok-apply-eglot-autostart (&optional table)
    "Register Eglot autostart hooks from TABLE (alist HOOK . SPEC).
Falls back to `grok-eglot-autostart-langs` if TABLE is nil,
but only if that variable is bound."
    (dolist (pair (or table
                      (and (boundp 'grok-eglot-autostart-langs)
                           grok-eglot-autostart-langs)))
      (let* ((hook (car pair))
             (spec (cdr pair))
             (mode (intern (string-remove-suffix "-hook" (symbol-name hook))))
             (override nil)
             (cmd nil))
        (cond
         ((stringp spec)
          (setq cmd (list spec)))
         ((consp spec)
          (when (eq (car spec) :override)
            (setq override t
                  spec (cdr spec)))
          (cond
           ((stringp spec)
            (setq cmd (list spec)))
           ((and (listp spec)
                 (let ((all-strings t))
                   (dolist (s spec)
                     (unless (stringp s) (setq all-strings nil)))
                   all-strings))
            (setq cmd spec)))))
        (when (and override cmd)
          (with-eval-after-load 'eglot
            (add-to-list 'eglot-server-programs (cons mode cmd))))
        (when (and cmd (executable-find (car cmd)))
          (add-hook hook #'eglot-ensure))))))

(use-package emacs
  ;; credit: autogenerated setup by ChatGPT "5 Thinking" (ãƒ„)_/Â¯
  ;; this code is not good, but works fine and is deferred until a user manually executes M-x `grok-show-binds' or clicks "grok.el Info" in the dashboard.
  ;; so no big deal.
  ;; scans grok.el for :binds, gets the PATH and eglot server setups, and displays all of this together in a read-only buffer
  :ensure nil
  :preface
  (defun grok-insert-eglot-server-programs (table)
    "Insert which eglot servers from TABLE are found on PATH.
TABLE is like `eglot-server-programs'."
    (when (and (boundp table) (symbol-value table))
      (dolist (entry (symbol-value table))
        (let* ((modes (car entry))
               (spec  (cdr entry))
               ;; normalize spec to a list-of-strings command if possible
               (cmd   (cond
                       ;; spec is a string -> wrap in list
                       ((stringp spec) (list spec))
                       ;; spec is a list of strings -> use directly
                       ((and (listp spec)
                             (cl-every #'stringp spec))
                        spec)
                       ;; spec is a dotted pair . <function> -> skip
                       ((and (consp spec)
                             (functionp (cdr spec))) nil)
                       (t spec))))
          (when (and (listp cmd)
                     (stringp (car cmd))
                     (executable-find (car cmd)))
            (insert (format "  %-40s -> %s\n"
                            (if (listp modes) (prin1-to-string modes) (symbol-name modes))
                            (mapconcat #'identity cmd " "))))))))
  (defun grok-insert-eglot-servers ()
    "Insert available Eglot servers from `grok-eglot-autostart-langs`.
Only runs if `grok-eglot-autostart-langs` is bound and non-nil."
    (when (bound-and-true-p grok-eglot-autostart-langs)
      (dolist (pair grok-eglot-autostart-langs)
        (let* ((hook (car pair))
               (spec (cdr pair))
               ;; unwrap (:override "cmd") etc.
               (cmd (cond
                     ((stringp spec) spec)
                     ((and (consp spec) (eq (car spec) :override))
                      (cadr spec))
                     (t nil))))
          (when (and cmd (executable-find cmd))
            (insert (format "  %-22s -> %s\n" hook cmd)))))))

  (defun grok-show-keybinds ()
    "Show Grok Emacs keybinds full-frame; press q to close.
Scans only `grokel` (or ~/.emacs.d/grok.el) for :bind."
    (interactive)
    (let* ((file (if (and (boundp 'grokel) grokel)
                     grokel
                   (expand-file-name "grok.el" user-emacs-directory)))
           (buf  (get-buffer-create "*Grok Keybinds*"))
           rows)
      ;; Parse grok.el, collect (MAP KEY CMD) from :bind only
      (when (and file (file-readable-p file))
        (let* ((content (with-temp-buffer
                          (insert-file-contents file)
                          (buffer-string)))
               (pos 0)
               res obj)
          (while (< pos (length content))
            (setq res (ignore-errors (read-from-string content pos)))
            (if (not res)
                (setq pos (length content))
              (setq obj (car res)
                    pos (cdr res))
              (when (and (consp obj) (eq (car obj) 'use-package))
                ;; Walk the arglist as a stream of keywords; each keyword consumes
                ;; all following non-keyword forms. This way multiple forms under
                ;; :init (etc.) don't break finding :bind.
                (let ((tail (cddr obj)))
                  (while tail
                    (let ((item (car tail)))
                      (setq tail (cdr tail))
                      (when (keywordp item)
                        (let ((kw item) (acc nil))
                          (while (and tail (not (keywordp (car tail))))
                            (push (car tail) acc)
                            (setq tail (cdr tail)))
                          (when (eq kw :bind)
                            (dolist (valform (nreverse acc))
                              (let ((lst (if (and (consp valform)
                                                  (or (stringp (car valform))
                                                      (eq (car valform) :map)
                                                      (consp (car valform))))
                                             valform
                                           (list valform)))
                                    (curm 'global))
                                (while lst
                                  (let ((x (car lst)))
                                    (setq lst (cdr lst))
                                    (cond
                                     ;; Flat plist style: :map MAP
                                     ((eq x :map)
                                      (when lst
                                        (setq curm (car lst))
                                        (setq lst (cdr lst))))
                                     ;; Grouped style: (:map MAP ...bindings...)
                                     ((and (consp x) (eq (car x) :map))
                                      (setq curm (cadr x))
                                      (setq lst (append (cddr x) lst)))
                                     ;; Binding: ("KEY" . cmd) / ("KEY" cmd) / ("KEY" #'cmd) / ("KEY" 'cmd)
                                     ((and (consp x) (stringp (car x)))
                                      (let* ((key (car x))
                                             (rhs (cdr x))
                                             (cmd (cond
                                                   ((symbolp rhs) rhs)
                                                   ((and (consp rhs) (symbolp (car rhs))) (car rhs))
                                                   ((and (consp rhs) (eq (car rhs) 'function)
                                                         (symbolp (cadr rhs))) (cadr rhs))
                                                   ((and (consp rhs) (eq (car rhs) 'quote)
                                                         (symbolp (cadr rhs))) (cadr rhs))
                                                   (t nil))))
                                        (when (and key cmd)
                                          (push (list curm key cmd) rows))))
                                     ;; Nested list -> flatten and continue
                                     ((consp x)
                                      (setq lst (append x lst)))
                                     ;; else ignore
                                     )))))))))))))))

        ;; Render buffer
        (with-current-buffer buf
          (read-only-mode -1)
          (erase-buffer)
          (insert (propertize
                   "\nBinds found in grok.el - Use M-x `grok-edit-grok-file' to modify\n\n"
                   'face 'success))
          (if rows
              (progn
                (setq rows
                      (sort rows
                            (lambda (a b)
                              (let* ((ma (symbol-name (or (nth 0 a) 'global)))
                                     (mb (symbol-name (or (nth 0 b) 'global)))
                                     (ka (nth 1 a))
                                     (kb (nth 1 b)))
                                (if (string= ma mb)
                                    (string< ka kb)
                                  (string< ma mb))))))
                (let ((curm nil))
                  (dolist (r rows)
                    (let ((m   (or (nth 0 r) 'global))
                          (key (nth 1 r))
                          (cmd (nth 2 r)))
                      (unless (eq m curm)
                        (setq curm m)
                        (insert (format "[%s]\n" (if (eq m 'global) "global" (symbol-name m)))))
                      (insert (format "  %-16s -> %s\n" key cmd))))))
            (insert (format "No :bind forms found in %s\n" file)))
          (insert "\n")
          (when (bound-and-true-p grok-env)
            (when (bound-and-true-p grok-env)
              (insert (concat (propertize "env modifications: " 'face 'success)
                              (format "%S" grok-env))))
            (insert "\n\n")
            (when (getenv "PATH")
              (insert (concat (propertize "PATH: " 'face 'success)
                              (format "%S" (getenv "PATH"))))))
          (when (bound-and-true-p grok-eglot-autostart-langs)
            (insert "\n\n")
            (insert (propertize "LSP servers found on PATH and configured to auto-start:\n"
                                'face 'success))
            (grok-insert-eglot-servers))
          (require 'eglot)
          (when (bound-and-true-p eglot-server-programs)
            (insert "\n")
            (insert (propertize "ALL LSP servers available on PATH:\n"
                                'face 'success))   ;; green-ish, theme-safe
            (grok-insert-eglot-server-programs 'eglot-server-programs))
          ;; (insert (propertize "ðŸ§™ Grok Wizardry\n" 'face 'success))
          (goto-char (point-min))
          (special-mode)
          (setq-local header-line-format (propertize "ðŸ§™ Grok Diagnostics ðŸŠâœ¨" 'face 'success)))
        (switch-to-buffer buf)
        (delete-other-windows)))))

(use-package emacs
  ;; some helpers
  :ensure nil
  :preface
  (defun grok-update-config-with-ediff ()
    "Ediff your grok.el against grok-defaults.el.  Useful after a 'git pull' in case of a breaking upstream change."
    (interactive)
    (ediff-files grokel grokfile))

  (defun grok-edit-init-file ()
    "Open init.el."
    (interactive)
    (find-file (expand-file-name "init.el" user-emacs-directory)))

  (defun grok-edit-grok-file ()
    "Open grok.el."
    (interactive)
    (find-file grokel))

  (defun grok-edit-grok-initial-setup-opts ()
    "Open grok-opts.el."
    (interactive)
    (find-file grok-opts-file))

  (defun grok-pop-flymake-diagnostics ()
    (interactive)
    (flymake-mode 1)
    (flymake-show-diagnostics-buffer)))

;; vanity

(use-package emacs
  ;; credit: autogenerated setup by ChatGPT "5 Thinking" (ãƒ„)_/Â¯
  :ensure nil
  :preface
  (defvar grok--splash-buf "*grok-splash*")
  (defvar grok--splash-child nil)

  (defun grok--splash-close (&optional _ev)
    (when (fboundp 'posframe-delete)
      (ignore-errors (posframe-delete grok--splash-buf)))
    (when (buffer-live-p (get-buffer grok--splash-buf))
      (kill-buffer grok--splash-buf))
    (when (and grok--splash-child (frame-live-p grok--splash-child))
      (delete-frame grok--splash-child))
    (setq grok--splash-child nil))

  (defun grok--splash-anykey-close ()
    "Close and re-send the key that dismissed the splash."
    (interactive)
    (let ((ev last-input-event))
      (grok--splash-close)
      (when ev (push ev unread-command-events))))

  (defun grok--dashboard-window ()
    (or (get-buffer-window "*dashboard*") (selected-window)))

  (defun grok-splash-overlay (&optional file anchor offset)
    "Floating image in SAME frame; press any key/click to close.
ANCHOR: 'window-center (default) | 'window-top-right
OFFSET: (DX . DY) pixels"
    (interactive)
    (when (display-graphic-p)
      (let* ((img (expand-file-name (or file "splash_smaller_transparent.png") user-emacs-directory))
             (image (and (file-readable-p img) (create-image img)))
             (buf   (get-buffer-create grok--splash-buf))
             (win   (grok--dashboard-window))
             (dx    (car (or offset '(0 . 0))))
             (dy    (cdr (or offset '(0 . 0)))))

        ;; buffer contents
        (with-current-buffer buf
          (setq mode-line-format nil header-line-format nil cursor-type nil
                truncate-lines t buffer-read-only t)
          (let ((inhibit-read-only t))
            (erase-buffer)
            (if image (insert-image image) (insert "(no splash.png)"))))

        ;; install one-shot global key catcher that re-injects the key
        (set-transient-map
         (let ((m (make-sparse-keymap)))
           (define-key m [t]       #'grok--splash-anykey-close)
           (define-key m [mouse-1] #'grok--splash-anykey-close)
           (define-key m [mouse-2] #'grok--splash-anykey-close)
           (define-key m [mouse-3] #'grok--splash-anykey-close)
           m) t)

        (if (and (featurep 'posframe) (fboundp 'posframe-show))
            ;; posframe path (no auto-hide, no focus)
            (posframe-show buf
                           :poshandler (pcase (or anchor 'window-center)
                                         ('window-top-right #'posframe-poshandler-window-top-right-corner)
                                         (_                 #'posframe-poshandler-window-center))
                           :position (window-start win)
                           :parent-frame (window-frame win)
                           :x-pixel-offset dx :y-pixel-offset dy
                           :accept-focus nil
                           :hidehandler (lambda (&rest _) nil)
                           :border-width 0
                           :respect-mode-line t :respect-header-line t
                           :override-parameters
                           '((undecorated . t) (skip-taskbar . t)
                             (no-other-frame . t) (internal-border-width . 0)))
          ;; manual child-frame (no taskbar, no focus)
          (let* ((par   (window-frame win))
                 (edges (window-pixel-edges win))
                 (L (nth 0 edges)) (T (nth 1 edges))
                 (R (nth 2 edges)) (B (nth 3 edges))
                 (iw (car (or (and image (image-size image t)) '(320 . 180))))
                 (ih (cdr (or (and image (image-size image t)) '(320 . 180))))
                 (child (make-frame `((name . "grok-splash")
                                      (parent-frame . ,par)
                                      (minibuffer . nil)
                                      (undecorated . t)
                                      (no-accept-focus . t)
                                      (skip-taskbar . t)
                                      (no-other-frame . t)
                                      (visibility . nil)
                                      (menu-bar-lines . 0)
                                      (tool-bar-lines . 0)
                                      (vertical-scroll-bars . nil)
                                      (internal-border-width . 0)))))
            (setq grok--splash-child child)
            (set-frame-size child (max 1 (round iw)) (max 1 (round ih)) t)
            (let* ((cw (frame-pixel-width child))
                   (ch (frame-pixel-height child))
                   (x (pcase (or anchor 'window-center)
                        ('window-top-right (+ R (- cw) dx))
                        (_ (+ L (/ (- (- R L) cw) 2) dx))))
                   (y (pcase (or anchor 'window-center)
                        ('window-top-right (+ T dy))
                        (_ (+ T (/ (- (- B T) ch) 2) dy)))))
              (set-frame-position child x y))
            (with-selected-frame child (switch-to-buffer buf))
            (make-frame-visible child))))))

  ;; Schedule -> slight delay so init noise won't auto-dismiss it.
  (defun grok-splash-overlay-later (&optional delay)
    (run-at-time (or delay 0.25) nil
                 (lambda () (grok-splash-overlay nil 'window-center '(0 . -20)))))
  (defun grok-splash-overlay-quit-later (&optional delay)
    "Show splash overlay after DELAY, then enqueue a fake C-g.
This way Emacs is returned to a clean state immediately, but the splash
remains visible until the user presses any key/click."
    (run-at-time (or delay 0.25) nil
                 (lambda ()
                   (push ?\C-g unread-command-events))))
  ;; trying to achieve a wider visual-studio style window setup
  (defun grok-fancy-setup ()
    (set-frame-size (selected-frame) 135 40)
    (treemacs)
    (switch-to-buffer "*dashboard*")))

(provide 'grok-bootstrap)
